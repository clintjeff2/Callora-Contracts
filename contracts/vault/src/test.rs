extern crate std;

use super::*;
use soroban_sdk::testutils::{Address as _, Events as _};
use soroban_sdk::{IntoVal, Symbol};

// ---------------------------------------------------------------------------
// init / balance
// ---------------------------------------------------------------------------

/// Initialising with an explicit balance stores that value and emits the event.
#[test]
fn init_with_balance_emits_event() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());

    // Invoke init inside as_contract so the SDK captures the published event.
    let events = env.as_contract(&contract_id, || {
        CalloraVault::init(env.clone(), owner.clone(), Some(1000));
        env.events().all()
    });

    // Balance must reflect the initial value.
    let client = CalloraVaultClient::new(&env, &contract_id);
    assert_eq!(client.balance(), 1000);

    // Exactly one event should have been emitted.
    let last_event = events.last().expect("expected at least one event");

    // Emitting contract must be our vault.
    assert_eq!(last_event.0, contract_id);

    // Topics: (Symbol("init"), owner)
    let topics = &last_event.1;
    assert_eq!(topics.len(), 2);
    let topic0: Symbol = topics.get(0).unwrap().into_val(&env);
    let topic1: Address = topics.get(1).unwrap().into_val(&env);
    assert_eq!(topic0, Symbol::new(&env, "init"));
    assert_eq!(topic1, owner);

    // Event data carries the starting balance.
    let data: i128 = last_event.2.into_val(&env);
    assert_eq!(data, 1000);
}

/// When no initial balance is provided the vault should default to zero.
#[test]
fn init_defaults_balance_to_zero() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    // Pass None — exercises the `unwrap_or(0)` branch in lib.rs.
    client.init(&owner, &None);
    assert_eq!(client.balance(), 0);
}

// ---------------------------------------------------------------------------
// get_meta
// ---------------------------------------------------------------------------

/// get_meta returns both the stored owner address and balance correctly.
#[test]
fn get_meta_returns_owner_and_balance() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    client.init(&owner, &Some(500));
    let meta = client.get_meta();

    assert_eq!(meta.owner, owner);
    assert_eq!(meta.balance, 500);
}

/// Calling get_meta before init must return an error (not a panic that kills
/// the test process) — exercises the `unwrap_or_else(panic)` error path.
#[test]
fn get_meta_before_init_fails() {
    let env = Env::default();
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    // try_get_meta() is the Result-returning variant generated by the SDK.
    let result = client.try_get_meta();
    assert!(result.is_err(), "expected error when vault is uninitialised");
}

// ---------------------------------------------------------------------------
// deposit
// ---------------------------------------------------------------------------

/// Depositing accumulates correctly and the returned value matches balance().
#[test]
fn deposit_and_balance_match() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    client.init(&owner, &Some(100));
    let returned = client.deposit(&200);

    assert_eq!(returned, 300, "deposit should return the new running balance");
    assert_eq!(client.balance(), 300);
}

// ---------------------------------------------------------------------------
// deduct
// ---------------------------------------------------------------------------

/// A valid deduction reduces the balance by exactly the requested amount.
#[test]
fn deduct_reduces_balance() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    client.init(&owner, &Some(100));
    client.deposit(&200);
    assert_eq!(client.balance(), 300);

    let returned = client.deduct(&50);
    assert_eq!(returned, 250, "deduct should return the remaining balance");
    assert_eq!(client.balance(), 250);
}

/// Deducting more than the available balance must be rejected — exercises the
/// `assert!(meta.balance >= amount, "insufficient balance")` guard.
#[test]
fn deduct_insufficient_balance_fails() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    client.init(&owner, &Some(10));

    // try_deduct() returns Result so we can assert on the error without
    // unwinding the test runner.
    let result = client.try_deduct(&100);
    assert!(result.is_err(), "expected error for insufficient balance");
}

/// Deducting exactly the full balance should succeed and leave zero.
#[test]
fn deduct_exact_balance_succeeds() {
    let env = Env::default();
    let owner = Address::generate(&env);
    let contract_id = env.register(CalloraVault {}, ());
    let client = CalloraVaultClient::new(&env, &contract_id);

    client.init(&owner, &Some(75));
    let remaining = client.deduct(&75);

    assert_eq!(remaining, 0);
    assert_eq!(client.balance(), 0);
}
